# voltorb-flip
Program to solve for best possible moves for the game voltorb flip.
Voltorb flip is a game that i enjoyed playing as a kid, one that i originally had seen in the game "Pokemon: SoulSilver". I recently decided to write this program, one that is meant to solve the game in the best possible fashion. As the game is not alway solveable with 100% certainty, this program determines the best possible move to do in order to give one the highest chance of advancing forward to the next level. The game is played as follows.

Each round begins with an empty board of 25 cards arranged in 5 rows and 5 columns facing downward. On the face-down side of each card, there is either a voltorb (for all intents and purposes of the game, this is just a zero. A "voltorb" is just a pokemon used to represent a 0), a one, a two, or a three. The object of the game is to flip over cards until all of the twos and threes are facing up. Once this is done, you have "won" the round. However, if a zero (a.k.a. a voltorb) is flipped before all the twos and threes are found, the round is lost. You are also given a few hints to assist you in finding all the twos and threes. To the right of each row, you are told how many zeros are in that row as well as what the sum of all the cards in that row are. Additionally, beneath each column, you are told how many zeros are in that column as well as the sum of all the cards in that column. You can easily find a simulation of this game online by looking for a game called "voltorb flip". Now some rounds are fully solveable by deductive reasoning: if a row or column has 0 zeros in it, then you are safe to turn over all the cards in that row and provide yourself with more information. Another method used is if the sum of the cards in a row 'S' plus the number of zeros in a row 'Z' add up to five (and hence S+Z=5) then one can deduce that no twos or threes can possibly be in that row (with similar deduction rules for columns) and hence, there is no real usefulness in turning any cards in that row or column since the game ends when all twos and threes are drawn. Flipping ones and zeros doesn't help end the roudn directly. However, there are some levels that you can not solve completely wihtout making an educated guess, or by simply choosing a card that has a low (but not zero) percent chance of drawing a zero and losing the round. That is where this program comes in handy. It will calculate which card is (probably) least likely to be a zero, and, further, which is most likely to be a two or a three.

To use the program, simply run the code and you will be presented with a GUI of empty entry boxes. Simply use the row/column labeled "S" to enter the sums shown on the board for each respective row and column, and use the row/column labeled "V" to enter the number of zeros (Voltorbs) in the respective row and column. Use the remaining 25 squares (where each square corresponds to a card on the table) to enter any values that you may have previously figured out by flipping cards on the board. After this is done, just press the solve button and you will be shown in the bottom right corner of the GUI which card should be flipped next. The answer is shown in the format (i,j) meaning you should select the card in the ith row and jth column, where columns and rows are numbered 1 to 5. Once you flip that card, enter into the GUI the value of that card in its respective entry box and click solve again to do another iteration with the new information from the newly flipped card. 

I do know that this may not be the absolute best probability calculation for each card, but i did the best that i believed i could without spending a disproportionate amount of time on the project since i did it for fun and, initially, just for myself before deciding to put it online. But i have had quite a bit of success using it and definitely performed better than i had before when i was going off my own intuition. 

Hopefully you can enjoy using this as much as i enjoyed making it. What a bit of nostalgia for me! I remember adoring this game when i was younger, and now, a good ten years later, here i am writing a program to solve it.
